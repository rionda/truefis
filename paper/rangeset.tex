\section{The range set of a collection of itemsets}\label{sec:range}
In this section we define the concept of a range set associated to a
collection of itemsets and show how to bound the VC-dimension and the
empirical VC-dimension of this range set. We use these definitions and results
to develop our algorithm in Sect.~\ref{sec:main}.

\begin{definition}\label{def:rangeset}
Given a collection $\mathcal{C}$ of itemsets built on a ground set $\Itm$, the
\emph{range set $\range(\mathcal{C})$ associated to $\mathcal{C}$ is a range
set on $2^\Itm$} containing the support sets of the itemsets in $\mathcal{C}$:
\[
	\range(\mathcal{C})=\{T(A) ~:~ A\in\mathcal{C}\}\enspace.
\]
\end{definition}

\begin{fact}\label{fact:maxfreq}
	Given this definition and a dataset $\Ds$, the maximum
	in~\eqref{eq:evceapprox} is attained for the itemset $A\in\mathcal{C}$ with the
	highest frequency in $\Ds$, and the value of $\sqrt{|r\cap S|}$ is exactly
	$\sqrt{f_\Ds(A)|\Ds|}$. Hence we can rewrite~\eqref{eq:evceapprox} as
	\begin{equation}\label{eq:evceapproxitemsets}
		\varepsilon = 2c\sqrt{\frac{2d\max_{A\in\mathcal{C}}f_\Ds(A)}{|\Ds|}} +
		\sqrt{\frac{2\ln\frac{4}{\delta}}{|\Ds|}}\enspace.
		% THIS IS HOW THE EQUATION USED TO BE BEFORE THE NEW BOUND
		%2\sqrt{\frac{\max_{A\in\mathcal{C}}f_\Ds(A)2\min\left\{\ln|\mathcal{C}|,d\ln\frac{en}{d}\right\}}{|\Ds|}} +
		%\sqrt{\frac{2\ln\frac{4}{\delta}}{|\Ds|}},
	\end{equation}
	where $\mathcal{C}$ is as in Def.~\ref{def:rangeset}, and $d$ is an
	upper bound to $\EVC(\range(\mathcal{C}),\Ds)$.
\end{fact}

The following Theorem presents an upper bound to the empirical VC-dimension of
$\range(\mathcal{C})$ on a dataset $\Ds$.

\begin{theorem}\label{lem:evcdimupbound}
  Let $\mathcal{C}$ be a collection of itemsets, $\Ds$ be a dataset, and $U$ be
  the set of items appearing in the itemsets of $\mathcal{C}$ ($U=\{a\in A ~:~
  A\in\mathcal{C}\}$). Let $d$ be the maximum integer for which there are at
  least $d$ transactions $\tau_1,\dotsc,\tau_d\in \Ds$ such that:
  \begin{itemize}
	\item the set $\{\tau_1\cap U,\dotsc,\tau_d\cap U\}$ is an antichain; and
	\item each $\tau_i$, $1\le i\le d$, contains at least $2^{d-1}$ itemsets
		from $\mathcal{C}$;
  \end{itemize}
  Then $\EVC(\range(\mathcal{C}),\Ds)\le d$.
\end{theorem}

\begin{proof}
  The antichain requirement guarantees that the set of transactions considered in
  the computation of $d$ could indeed theoretically be shattered. Assume that a
  subset $\mathcal{F}$ of $\Ds$ contains two transactions $\tau'$ and $\tau''$
  such that, w.l.o.g., $\tau' \cap U\subseteq\tau''\cap U$. Any itemset from
  $\mathcal{C}$ appearing in $\tau'$ would also appear in $\tau''$, so there
  would not be any itemset $A\in\mathcal{C}$ such that $\tau''\in T(A)\cap
  \mathcal{F}$ but $\tau'\not\in T(A)\cap \mathcal{F}$, which would imply that
  $\mathcal{F}$ can not be shattered. Hence sets of transactions that are not
  antichains should not be considered.
  %This has the net effect of potentially resulting in a lower $d$,
  %i.e., in a stricter upper bound to $\EVC(\range(\mathcal{C}),\Ds)$.

  Let now $\ell>d$ and consider a set $\mathcal{L}$ of $\ell$ transactions from
  $\Ds$ that satisfies the antichain requirement. Assume that $\mathcal{L}$ is
  shattered by $\range(\mathcal{C})$. Let $\tau$ be a transaction in
  $\mathcal{L}$. The transaction $\tau$ belongs to $2^{\ell-1}$ subsets of $L$.
  Let $\mathcal{K}\subseteq \mathcal{L}$ be one of these subsets. Since
  $\mathcal{L}$ is shattered, there exists an itemset $A\in\mathcal{C}$ such
  that $T(A)\cap \mathcal{L}=\mathcal{K}$. From this and the fact that $t\in
  \mathcal{K}$, we have that $\tau\in T(A)$ or equivalently that
  $A\subseteq\tau$. Given that all the subsets $\mathcal{K}\subseteq\mathcal{L}$
  containing $\tau$ are different, then also all the $T(A)$'s such that
  $T(A)\cap \mathcal{L}=\mathcal{K}$ should be different, which in turn implies
  that all the itemsets $A$ should be different and that they should all appear
  in $\tau$. There are $2^{\ell-1}$ subsets $\mathcal{K}$ of $\mathcal{L}$
  containing $\tau$, therefore $\tau$ must contain at least $2^{\ell-1}$
  itemsets from $\mathcal{C}$, and this holds for all $\ell$ transactions in
  $\mathcal{L}$. This is a contradiction because $\ell>d$ and $d$ is the maximum
  integer for which there are at least $d$ transactions containing at least
  $2^{d-1}$ itemsets from $\mathcal{C}$. Hence $\mathcal{L}$ cannot be shattered
  and the thesis follows.
\end{proof}

Generalizing a concept by~\citet{RiondatoU14}, we call $d$ as defined in
Thm.~\ref{lem:evcdimupbound} the \emph{d-index of $\mathcal{C}$ in $\Ds$}.

The antichain requirement from Thm.~\ref{lem:evcdimupbound} implies that, in the
set that gives origin to the d-index, there is no $\tau_i$, $1\le i\le d$ such
that $U\subseteq\tau_i$ (i.e., no $\tau_i$ for which $\tau_i\cap U=U$).

Instead of $\mathcal{C}$, one can consider a filtered version
$\mathcal{C}^*$ of $\mathcal{C}$ containing only the itemsets of $\mathcal{C}$
that are \emph{closed} in $\Ds$, i.e., for which no superset of them has the same
frequency in $\Ds$~\citep{CaldersRB06}. From the definitions of the ranges and
considering their intersections with $\Ds$, it is easy to see that the empirical
VC-dimension of $\mathcal{C}^*$ on $\Ds$ is the same as the empirical
VC-dimension of $\mathcal{C}$ on $\Ds$. Unless one already has access to the
frequencies of the itemsets in $\mathcal{C}$, this filtering operation would
require mining the dataset to obtain such frequencies. For clarity of
presentation, we will not consider the filtering step in the following
sections, but the reader should keep in mind that it can be applied whenever the
frequencies of the itemsets in $\mathcal{C}$ are available.

Mutuating a construction by~\citet{RiondatoU14}, one can show that the bound in
Thm.~\ref{lem:evcdimupbound} is tight, in the sense that there are datasets
such that the empirical VC-dimension of $\mathcal{C}$ on them is equal to the
d-index of $\mathcal{C}$ on them.

\subsection{Computing the empirical VC-Dimension}\label{sec:computvc}
We now present different methods to compute upper bounds to the d-index of an
itemset collection $\mathcal{C}$ in a dataset $\Ds$. We start from an exact
algorithm which may be too expensive in practice and then discuss a number of
variants that trade off accuracy for speed.

\subsubsection{Exact algorithm and faster variants}
The exact algorithm (which we call \texttt{EVCBoundExact}) for the d-index of
$\mathcal{C}$ on $\Ds$ starts by scanning $\Ds$ and computing, for each
transaction $\tau\in\Ds$, the set $I_\tau=\tau\cap U$. If $I\tau\neq U$, then an
element with key $\tau\cap U$ and value $|\{A\in\mathcal{C} ~:~
A\subseteq\tau\}|$ is added to a hash table $L$, if no element with the same key
was already present. The value is the number of itemsets of $\mathcal{C}$ that
appear in any transaction whose intersection with $U$ is $I_\tau$. Once the scan
is complete, let $d_1$ be the maximum $d$ for which there are at least $d$ keys
in $L$ with value at least $2^{d-1}$. Formally, if we define, for any
$d\in\mathbb{N}$
\[
	T_d=\{A\subset U ~:~ L[A]\ge 2^{d-1}\},
\]
then $d_1=\max\{d ~:~ |T_d|\ge d\}$.
Let now $b_1$ be the size of the largest antichain on $T_{d_1}$, obtained by
solving the corresponding maximum bipartite matching problem. If $b_1\ge d_1$,
then the algorithm can return $b_1$. Otherwise, for $i>1$, let $d_i$ be the
maximum $d$ such that $|T_d\setminus T_{d_{i-1}}|\ge d-b_{i-1}$, where $b_{i-1}$
is the size of the largest antichain on $T_{d_{i-1}}$:
\[
	d_i=\max\{d<d_{i-1} ~:~ |T_d\setminus T_{d_{i-1}}|\ge d-b_{i-1}\}\enspace.
\]
We then compute the size $b_i$ of the largest antichain on $T_{d_i}$ and return
$b_i$ if $b_i\ge d_i$. Note that if $d_i\le b_{i-1}$, we can actually avoid
computing $b_i$ and return $d_i$ immediately.

The pseudocode of \texttt{EVCBoundExact} is presented in
Alg.~\ref{alg:evcboundexact}. The algorithm obviously terminates because in the
worst case there will be an index $i$ such that $d_i=1$, and any set containing
a single transaction is an antichain of size 1, so $b_i=d_1=1$, and the
algorithm terminates.

\begin{algorithm}[htbp]
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKwComment{Comment}{\quad// }{}
  \SetKw{MyAnd}{and}
  \SetKw{MyTo}{to}
  \DontPrintSemicolon
  \Input{Dataset $\Ds$, collection $\mathcal{C}$ of itemsets.}
  \Output{d-index of $\mathcal{C}$ in $\Ds$.}
  $U\leftarrow\{a\in A, A\in\mathcal{C}\}$\;
  $L\leftarrow$ empty hash table\;
  $T\leftarrow$ empty hash table\;
  \For{$\tau\in\Ds$}{\label{algline:forbegin}
		$I_\tau\leftarrow \tau\cap U$\;
		\If{$I_\tau\neq U$ \MyAnd $I_\tau\neq\emptyset$ \MyAnd $L$ does not
		contain an element with key $I_\tau$} {
			$\mathcal{C}_\tau\leftarrow \emptyset$\;
			\For{$A\in\mathcal{C}$}{\label{algline:intersectionloopbegin}
				\If{$A\subseteq I_\tau$}{
					$\mathcal{C}_\tau\leftarrow \mathcal{C}_\tau\cup\{A\}$\;
				}
			}\label{algline:intersectionloopend}
			$L[I_\tau]\leftarrow
			|\mathcal{C}_\tau|$\;\label{algline:assignmentintersection}
			\For{$d\leftarrow 1 $ \MyTo $\lfloor\log_2\ell\rfloor +1$}{
				$T[d]\leftarrow T[d]\cup\{I_\tau\}$\;
			}
		}
  }\label{algline:forend}
  $b_0\leftarrow 0$\;\label{algline:beginreplace}
  $d_0\leftarrow 0$\;
  $T[0]\leftarrow\emptyset$\;
  $i\leftarrow 1$\;
  \While{True} {\label{algline:secondloopbegin}
	$d_i=\max\{ d ~:~ |T[d]\setminus T[d_{i-1}]|\ge d-b_{i-1}\}$\;
	\If{$d_i\le b_{i-1}$}{
		\Return{$d_i$}\;
	}
	$b_i\leftarrow$ size of largest antichain on
	$T[d_i]$\;\label{algline:antichain}
	\If{$b_i \ge d_i$}{
		\Return{$d_i$}
	}
  }\label{algline:secondloopend}
  \caption{\texttt{EVCBoundExact}: compute the d-index of $\mathcal{C}$ in
  $\Ds$.}
  \label{alg:evcboundexact}
\end{algorithm}

\begin{lemma}\label{lem:evcboundexactcorrect}
	\texttt{EVCBoundExact} computes the d-index of $\mathcal{C}$ in $\Ds$.
\end{lemma}
\begin{proof}
	The algorithms stops in two cases: either there is an index $i$ such that
	$b_i\ge d_i$, or there is an index $i$ such that $d_i\le b_{i-1}$. We now
	consider the two cases separately.

	\begin{description}
		\item{Case 1.} Let $i$ be the index such that $b_i\ge d_i$. Then, there
			is an antichain of size at least $d_i$ on $T_{d_i}$. Now, $T_{d_i}$
			contains all and only the sets of the form $I_\tau=\tau\cap U$,
			where $\tau$ is a transaction in $\Ds$, such that $I_\tau$ (and
			therefore $\tau$) contains at least $2^{d_i-1}$ itemsets from
			$\mathcal{C}$. From the definition of the sequence $d_j$, we have
			that $d_i$ is the maximum value for which
			we can find a collection of $d_i$ transactions
			$\{\tau_1,\dotsc,\tau_{d_i}\}\subseteq\Ds$ for which the sets
			$\tau_j\cap U$ form an antichain and such that each of these sets
			contains at least $2^{d_i-1}$ itemsets of $\mathcal{C}$. This is
			exactly the definition of the d-index of $\mathcal{C}$ on $\Ds$,
			hence the algorithm returns the correct value in this case.
		\item{Case 2.} Let $i$ be the index such that $d_i\le b_{i-1}$. From the
			definition of $b_{i-1}$, we know that there is an antichain of size
			$b_{i-1}$ on $T_{d_{i-1}}$. Since $T_{d_{i-1}}\subseteq T_{d_i}$,
			there is an antichain of size $b_{i-1}$ also on $T_{d_1}$ (the same
			antichain). So there is an antichain of size at least $d_i$ on
			$T_{d_i}$. The proof then follows as in the previous case.
	\end{description}
\end{proof}

\paragraph{Trade-off accuracy for speed.} The complexity of
\texttt{EVCBoundExact} is clearly polynomial in the sizes of $\Ds$,
$\mathcal{C}$, and $U$, but indeed some steps are quite expensive. In
particular, there are two steps whose cost could be cut, at the expenses of
obtaining an upper bound to the d-index:
\begin{enumerate}
	\item each iteration of the loop on
		lines~\ref{algline:secondloopbegin}--\ref{algline:secondloopend} in
		Alg.~\ref{alg:evcboundexact} requires to solve a maximum bipartite
		matching problem which can be done in polynomial time but may still be
		costly in practice;
	\item the loop on
		lines~\ref{algline:intersectionloopbegin}--\ref{algline:intersectionloopend}
		requires to iterate over each element of $\mathcal{C}$, which can be
		very large.
\end{enumerate}

We can replace lines~\ref{algline:beginreplace}--\ref{algline:secondloopend}
with the pseudocode in Algorithm~\ref{alg:replacement}
\begin{algorithm}[h!]
	\DontPrintSemicolon
	$d\leftarrow 1$\;
	$\kappa\leftarrow$ any key in $L$\;
	$\mathcal{T}\leftarrow\{\kappa\}$\;
	\ForEach{key $k$ in $L$, except $\kappa$}{
		\If{$L[k]\ge 2^{d-1}$}{
			$\mathcal{R}\leftarrow\mathcal{T}\cup\{k\}$\;
			$d\leftarrow$ maximum integer $q$ such that $\mathcal{R}$ contains
			at least $q$ elements $c$ with $L[c]\ge 2^{q-1}$\;
			$\mathcal{T}\leftarrow$ set of the $d$ elements of $\mathcal{R}$ with
			largest values in $L$ (ties broken arbitrarily)\;
		}
	}
	\Return{$d$}\;
	\caption{Replacement for
		lines~\ref{algline:beginreplace}--\ref{algline:secondloopend} in
		Alg.~\ref{alg:evcboundexact}.}
	\label{alg:replacement}
\end{algorithm}
The correctness of the algorithm with this replacement (we denote the resulting
algorithm as \texttt{EVCBoundScan}) follows from the fact that at any iteration
of the loop, the set $\mathcal{T}$ always contains $d$ elements of the form
$I_\tau=\tau\cap U$ for $\tau\in\Ds$ such that each element in $\mathcal{T}$
contains at least $2^{d-1}$ itemsets from $\mathcal{C}$ and $d$ is the maximum
integer for which such a set exists, among the keys of $L$ seen up to the
current iteration. This means that the value returned by \texttt{EVCBoundScan}
is an upper bound to the d-index, as we are relaxing the antichain requirement.

The running time is greatly improved compared to \texttt{EVCBoundScan} because
now this part of the algorithm requires a single scan of the keys in $L$, and
the work per key is minimal.

As for the loop on
lines~\ref{algline:intersectionloopbegin}--\ref{algline:intersectionloopend} of
Alg.~\ref{alg:evcboundexact}, we can use $2^{|I_\tau|}$ as an upper bound to the
exact number of itemsets of $\mathcal{C}$ that appear in $\mathcal{C}$, and
so-modified algorithm will clearly return an upper bound to the d-index. The
algorithm with both modification, which we call \texttt{EVCBoundScanFast},
requires time approximately proportional to two scans of the dataset, at the
price of a obtaining a looser bound to the empirical VC-dimension of
$\mathcal{C}$ on $\Ds$.

\subsubsection{Integer programming method}
We now present another algorithm to compute an upper bound to the d-index of an
itemset collection $\mathcal{C}$ on a dataset $\Ds$, and therefore to the
empirical VC-dimension of $\mathcal{C}$ on $\Ds$. The algorithm, which we call
\texttt{EVCBoundSUKP} requires to solve a \emph{Set Union Knapsack Problem}
(SUKP)~\citep{GoldschmidtNY94} associated to the collection $\mathcal{C}$.

\begin{definition}[Set Union Knapsack Problem (SUKP)\citep{GoldschmidtNY94}]\label{def:sukp}
  Let $U=\{a_1,\dotsc,a_\ell\}$ be a set of elements and let
  $\mathcal{S}=\{A_1,\dotsc,A_k\}$ be a set of subsets of $U$, i.e.,
  $A_i\subseteq U$ for $1\le i\le k$. Each subset $A_i$, $1\le i\le k$, has an
  associated non-negative \emph{profit} $\rho(A_i)\in\mathbb{R}^+$, and each
  element $a_j$, $1\le j\le\ell$ as an associated non-negative weight
  $w(a_j)\in\mathbb{R}^+$.  Given a subset $\mathcal{S}'\subseteq\mathcal{S}$,
  we define the profit of $\mathcal{S}'$ as $P(\mathcal{S}')=\sum_{A_i\in
  \mathcal{S}'}\rho(A_i)$. Let $U_{\mathcal{S}'}=\cup_{A_i\in\mathcal{S}'}
  A_i$. We define the weight of $\mathcal{S}'$ as $W(\mathcal{S}')=\sum_{a_j\in
  U_{\mathcal{S}'}} w(a_j)$. Given a non-negative parameter $c$ that we call
  \emph{capacity}, the \emph{Set-Union Knapsack Problem} (SUKP) requires to find
  the set $\mathcal{S}^*\subseteq\mathcal{S}$ which \emph{maximizes}
  $P(\mathcal{S}')$ over all sets $\mathcal{S}'$ such that $W(\mathcal{S}')\le
  c$.
\end{definition}

In our case, $U$ is the set of items that appear in the itemsets of
$\mathcal{C}$, $\mathcal{S}=\mathcal{C}$, the profits and the weights are all
unitary, and the capacity constraint is an integer $\ell$. We call this
optimization problem the \emph{SUKP associated to $\mathcal{C}$ with capacity
$\ell$}. It is easy to see that the optimal profit $p$ of this SUKP is the
number of itemsets from $\mathcal{C}$ that can be built using $\ell$
items from $U$:
\[
	p=\max_{\substack{\mathcal{A}\subseteq\mathcal{C}\\ |\cup_{A\in\mathcal{A}}
A|\le\ell}} |\mathcal{A}|\enspace.
\]

Consider the set $\Ds_\mathcal{C} = \{ \tau \cap U, \tau\in \Ds\}$ (which is a
\emph{set}, not a bag, hence it does not contain duplicates, even if $\Ds$
contains multiple identical transactions). Let $\ell_1,\dotsc,\ell_w$ be the
sequence of the sizes of the elements of $\Ds_\mathcal{C}$, i.e., for each value
$\ell$ for which there is at least one element in $\Ds_\mathcal{C}$ of size
$\ell$, there is one (and only one) index $i$, $1\le i\le w$ such that
$\ell_i=\ell$. Assume that the $\ell_i$'s are labelled in sorted decreasing
order: $\ell_1>\ell_2>\dotsb>\ell_w$. Let now $L_i$, $1\le i\le w$ be the number
of elements of $\Ds_\mathcal{C}$ that have size at least $\ell_i$. %and such that
%for no two $\tau'$, $\tau''$ of them we have either $\tau'\subseteq\tau''$ or
%$\tau''\subseteq\tau'$.
Let now $q_i$ be the optimal profit of the SUKP associated to $\mathcal{C}$ with
capacity $L_i$, and let $b_i=\lfloor \log_2q_i\rfloor +1$. %The sequences
%$(\ell_i)_1^w$ and a sequence $(L_i^*)^w$ of upper bounds to $(L_i)_1^w$ can be
%computed efficiently with a scan of $\Ds_\mathcal{C}$.
The following lemma shows how to use these sequences to obtain an upper bound
to the empirical VC-dimension of $\mathcal{C}$ on $\Ds$. We call the resulting
method \texttt{EVCBoundSUKP}, and present its pseudocode in
Alg.~\ref{alg:evcboundsukp}.

\begin{lemma}\label{lem:sukpevc}
  Let $j$ be the minimum integer for which $b_i\le L_i$. Then
  $\EVC(\mathcal{C},\Ds)\le b_j$.
\end{lemma}
\begin{proof}
  If $b_j\le L_j$, then there are at least $b_j$ elements of $\Ds_\mathcal{C}$
  which can contain $2^{b_j-1}$ itemsets from $\mathcal{C}$ and this is the
  maximum $b_i$ for which it happens, because the sequence $b_1,b_2,\dotsc,b_w$
  is sorted in decreasing order, given that the sequence $q_1,q_2,\dotsc,q_w$
  is. Then $b_j$ satisfies the conditions of Lemma~\ref{lem:evcdimupbound}.
  Hence $\EVC(\mathcal{C},\Ds)\le b_j$.
\end{proof}

\begin{algorithm}[htbp]
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKwFunction{SolveSUKP}{solveSUKP}
  \SetKwComment{Comment}{\quad// }{}
  \SetKw{MyAnd}{and}
  \DontPrintSemicolon
  \Input{Dataset $\Ds$, collection $\mathcal{C}$ of itemsets.}
  \Output{Upper bound to $\EVC(\range(\mathcal{C}),\Ds)$.}
  $U\leftarrow\{a\in A, A\in\mathcal{C}\}$\;
  $\Ds_\mathcal{C}\leftarrow\emptyset$\;
  $L\leftarrow$ empty hash table\;
  \For{$\tau\in\Ds$}{
		$I_\tau\leftarrow \tau\cap U$\;
		\If{$I_\tau\neq U$ \MyAnd $I_\tau\neq\emptyset$ \MyAnd $I_\tau
			\not\in\Ds_\mathcal{C}$} {
				$\Ds_\mathcal{C} \leftarrow \Ds_\mathcal{C} \cup \{I_\tau\}$\;
				\If{$L$ has no element with key $|I_\tau|$} {
					$L[|I_\tau|]\leftarrow 1$\;
				}
				\ForEach{key $k$ in $L$ such that $k<|I_\tau|$}{
					$L[k]\leftarrow L[k]+1$\;
			}
		}
  }
  $i\leftarrow 1$\;
  \While{$i\le$ number of keys in $L$}{
	$\ell_i\leftarrow $ $i$-th highest key in $L$\;
	$q_i\leftarrow$\SolveSUKP{$U$, $\mathcal{C}$, $\ell_i$}\;
	$b_i\leftarrow\lfloor\log_2 q_i\rfloor +1$\;
	\If{$b_i\le L[\ell_i]$}{
		\Return{$b_i$}\;
	}
	$i\leftarrow i+1$\;
  }
  \Return{$\min\{L[\ell_i],\log_2|\mathcal{C}|\}$}\;
  \caption{\texttt{EVCBoundSUKP}: compute an upper bound to
  $\EVC(\range(\mathcal{C}),\Ds)$.}
  \label{alg:evcboundsukp}
\end{algorithm}

\paragraph{Complexity and runtime considerations.} Solving the SUKP optimally
is NP-hard in the general case, although there are known restrictions for which
it can be solved in polynomial time using dynamic
programming~\citep{GoldschmidtNY94}. Since we have unit weights and unit
profits, our SUKP is equivalent to the \emph{densest $k$-subhypergraph} problem,
which can not be approximated within a factor of $2^{O(\log n)^\delta}$ for any
$\delta>0$ unless $3STA \in
DTIME(2^{n^{3/4+\varepsilon}})$~\citep{HajiaghayiJKLMRSV06}. A greedy algorithm
by~\citet{Arulselvan14} allows a constant factor approximation if each item only
appears in a constant fraction of itemsets of $\mathcal{C}$. For our case, it is
actually \emph{not necessary to compute the optimal solution} to the SUKP: any
solution $S$ for which we can prove that there is no power of two
between $S$ and the optimal solution would result in the same upper
bound to the (empirical) VC-dimension, while substantially speeding up the
computation. This property can be specified in currently available optimization
problem solvers (e.g., CPLEX), which can then can compute the bound to the
(empirical) VC-dimension very fast even for very large instances with thousands
of items and hundred of thousands of itemsets in $\mathcal{C}$, making this
approach practical.

{\bf PER MATTEO:} Dovremmo anche dire qualcosa sulla differenza tra questo
algoritmo e quelli di prima, e perche' lo presentiamo. La differenza e' che gli
algoritmi presentati prima o sfruttano completamente la struttura di
$\mathcal{C}$ (\texttt{EVCBoundExact}, \texttt{EVCBoundScan}), o la ignorano
quasi completamente (\texttt{EVCBoundScanFast}). Questo algoritmo cerca un middle
ground, in cui informazioni riguardo alla struttura vengono sfruttate per
ottenere un bound migliore al numero di itemsets di $\mathcal{C}$ che possono
apparire in una transazione $\tau$ la cui intersezione con $U$ ha taglia $\ell$.
In piu', come sara' piu' evidente quando facciamo le modifiche antichain,
\texttt{EVCBoundScanFast} non e' applicabile per le antichain, perche' non porta
nessun vantaggio. D'altra parte, \texttt{EVCBoundExact} e \texttt{EVCBoundScan}
modificati per l'antichain sono eccessivamente costly, perche' richiedono di
calcolare prima l'esatta collezione $\mathcal{C}_\tau$ di itemset di
$\mathcal{C}$ che appaiono in $\tau$, e poi la massima taglia di un antichain su
$\mathcal{C}_\tau$. Questo diventa eccessivamente costoso, secondo me, e il SUKP
cerca un middle ground.  C'e' poi una qualche questione teorica/pratica qui:
risolvere il SUKP e' in generale NP-hard, mentre fare quello che e' richiesto
dai \texttt{EVCBoundExact} modificati per l'antichain e' comunque polinomiale.
On the other hand, come osservato nel paragrafo prima, noi non abbiamo bisogno
della soluzione ottima. Insomma, siamo in una sitazione un po' nebulosa
